# 在阿里云VNC中直接复制粘贴执行以下命令

# 第一步：创建项目目录
mkdir -p /opt/DipMaster-Trading-System
cd /opt/DipMaster-Trading-System

# 第二步：安装依赖
yum update -y
yum install -y python3 python3-pip git screen htop

# 第三步：创建配置文件
mkdir -p config
cat > config/paper_trading_config.json << 'EOF'
{
  "strategy_name": "DipMaster_Linux_Paper_Trading",
  "version": "1.0.0",
  "trading": {
    "paper_trading": true,
    "initial_capital": 10000,
    "symbols": ["BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "BNBUSDT"],
    "max_concurrent_positions": 3,
    "position_size_usd": 800
  },
  "risk_management": {
    "global_settings": {
      "max_daily_loss_usd": 300,
      "max_drawdown_percent": 8.0
    }
  },
  "logging_and_monitoring": {
    "log_level": "INFO",
    "detailed_trade_logging": true,
    "save_results": true
  }
}
EOF

# 第四步：创建依赖文件
cat > requirements.txt << 'EOF'
numpy>=1.21.0
pandas>=1.3.0
asyncio
requests>=2.28.0
EOF

# 第五步：安装Python包
pip3 install -r requirements.txt

# 第六步：创建交易脚本 (这个文件比较大，分段复制)
# --- 先创建主脚本文件开头 ---
cat > run_paper_trading.py << 'EOF'
#!/usr/bin/env python3
"""DipMaster Linux纸面交易脚本"""

import asyncio
import json
import logging
import signal
import sys
import time
import random
from datetime import datetime, timedelta
from pathlib import Path
import argparse

class DipMasterPaperEngine:
    def __init__(self, config):
        self.config = config
        self.running = False
        self.start_time = None
        self.capital = float(config['trading']['initial_capital'])
        self.initial_capital = self.capital
        self.positions = {}
        self.trade_history = []
        
        self.stats = {
            'total_signals': 0,
            'total_trades': 0,
            'winning_trades': 0,
            'total_pnl': 0.0,
            'max_drawdown': 0.0
        }
        
        self.setup_logging()
        self.logger = logging.getLogger(self.__class__.__name__)
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def setup_logging(self):
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_file = log_dir / f"dipmaster_paper_{timestamp}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
    
    def _signal_handler(self, signum, frame):
        self.logger.info(f"接收到信号 {signum}, 停止交易...")
        self.running = False
    
    def simulate_market_data(self):
        """模拟市场数据"""
        base_prices = {
            'BTCUSDT': 43000, 'ETHUSDT': 2500, 'ADAUSDT': 0.45, 
            'SOLUSDT': 95, 'BNBUSDT': 310
        }
        
        market_data = {}
        for symbol in self.config['trading']['symbols']:
            base_price = base_prices.get(symbol, 100)
            price_change = random.uniform(-0.03, 0.03)
            current_price = base_price * (1 + price_change)
            
            market_data[symbol] = {
                'symbol': symbol,
                'price': round(current_price, 4),
                'price_change_pct': price_change * 100,
                'rsi_14': random.uniform(25, 75),
                'is_dip': price_change < -0.005,
                'volume_ratio': random.uniform(0.8, 2.5),
                'timestamp': datetime.now()
            }
        
        return market_data
    
    def detect_dipmaster_signal(self, symbol_data):
        """DipMaster信号检测"""
        symbol = symbol_data['symbol']
        
        conditions = {
            'rsi_condition': 30 <= symbol_data['rsi_14'] <= 50,
            'dip_condition': symbol_data['is_dip'],
            'volume_condition': symbol_data['volume_ratio'] > 1.3,
            'price_condition': symbol_data['price_change_pct'] < -0.2
        }
        
        score = sum(conditions.values())
        confidence = score / len(conditions)
        
        self.stats['total_signals'] += 1
        
        if confidence >= 0.75 and random.random() < 0.15:
            return {
                'symbol': symbol,
                'action': 'BUY',
                'price': symbol_data['price'],
                'confidence': confidence,
                'rsi': symbol_data['rsi_14'],
                'timestamp': datetime.now()
            }
        
        return None
    
    def execute_trade(self, signal):
        """执行交易"""
        symbol = signal['symbol']
        
        if len(self.positions) >= self.config['trading']['max_concurrent_positions']:
            return False
        
        if symbol in self.positions:
            return False
        
        position_size = self.config['trading']['position_size_usd']
        
        trade = {
            'id': len(self.trade_history) + 1,
            'symbol': symbol,
            'entry_price': signal['price'],
            'position_size_usd': position_size,
            'entry_time': datetime.now(),
            'exit_price': None,
            'pnl': 0.0,
            'status': 'OPEN'
        }
        
        self.positions[symbol] = trade
        self.trade_history.append(trade)
        self.stats['total_trades'] += 1
        
        self.logger.info(f"📈 开仓: {symbol} @ ${signal['price']:.4f}, ${position_size}")
        return True
    
    def check_exit_conditions(self, position, market_data):
        """检查出场条件"""
        symbol = position['symbol']
        current_price = market_data[symbol]['price']
        entry_price = position['entry_price']
        entry_time = position['entry_time']
        
        holding_time = datetime.now() - entry_time
        holding_minutes = holding_time.total_seconds() / 60
        pnl_pct = (current_price - entry_price) / entry_price
        
        exit_reasons = []
        
        # 15分钟边界
        if holding_minutes >= 15:
            minute_in_hour = holding_minutes % 60
            if 14 <= minute_in_hour <= 16 or 29 <= minute_in_hour <= 31:
                exit_reasons.append("15分钟边界")
        
        # 目标利润
        if pnl_pct >= 0.008:
            exit_reasons.append("目标利润")
        
        # 止损
        if pnl_pct <= -0.012:
            exit_reasons.append("止损")
        
        # 最大持仓时间
        if holding_minutes >= 180:
            exit_reasons.append("最大持仓时间")
        
        return exit_reasons
    
    def close_position(self, position, market_data, exit_reasons):
        """平仓"""
        symbol = position['symbol']
        current_price = market_data[symbol]['price']
        entry_price = position['entry_price']
        position_size = position['position_size_usd']
        
        pnl_pct = (current_price - entry_price) / entry_price
        pnl_usd = position_size * pnl_pct
        
        position['exit_price'] = current_price
        position['exit_time'] = datetime.now()
        position['pnl'] = pnl_usd
        position['status'] = 'CLOSED'
        
        self.capital += pnl_usd
        self.stats['total_pnl'] += pnl_usd
        
        if pnl_usd > 0:
            self.stats['winning_trades'] += 1
        
        holding_time = datetime.now() - position['entry_time']
        
        emoji = "💰" if pnl_usd > 0 else "📉"
        self.logger.info(f"{emoji} 平仓: {symbol} @ ${current_price:.4f} | "
                        f"盈亏: ${pnl_usd:+.2f} ({pnl_pct*100:+.2f}%) | "
                        f"时间: {holding_time.total_seconds()/60:.1f}分钟")
        
        del self.positions[symbol]
    
    def print_status(self):
        """打印状态"""
        if not self.start_time:
            return
        
        runtime = datetime.now() - self.start_time
        win_rate = (self.stats['winning_trades'] / max(self.stats['total_trades'], 1)) * 100
        roi = (self.capital - self.initial_capital) / self.initial_capital * 100
        
        status = f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 DipMaster状态 (运行: {str(runtime).split('.')[0]})
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💰 资金: ${self.capital:.2f} | ROI: {roi:+.2f}%
📈 交易: {self.stats['total_trades']} | 胜率: {win_rate:.1f}%
💹 盈亏: ${self.stats['total_pnl']:+.2f} | 持仓: {len(self.positions)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        """
        self.logger.info(status)
    
    async def run_trading_session(self, duration_hours=168):
        """运行交易"""
        self.running = True
        self.start_time = datetime.now()
        
        self.logger.info(f"🚀 DipMaster启动! 初始资金: ${self.capital}")
        self.logger.info(f"⏱️ 运行时长: {duration_hours}小时")
        
        last_status_time = datetime.now()
        
        try:
            while self.running:
                if (datetime.now() - self.start_time).total_seconds() > duration_hours * 3600:
                    self.logger.info(f"⏰ 达到运行时间 {duration_hours} 小时")
                    break
                
                market_data = self.simulate_market_data()
                
                # 检查出场
                for symbol in list(self.positions.keys()):
                    position = self.positions[symbol]
                    exit_reasons = self.check_exit_conditions(position, market_data)
                    if exit_reasons:
                        self.close_position(position, market_data, exit_reasons)
                
                # 检查入场
                for symbol_data in market_data.values():
                    signal = self.detect_dipmaster_signal(symbol_data)
                    if signal:
                        self.execute_trade(signal)
                
                # 30分钟状态报告
                if datetime.now() - last_status_time >= timedelta(minutes=30):
                    self.print_status()
                    last_status_time = datetime.now()
                
                await asyncio.sleep(60)  # 1分钟周期
                
        except KeyboardInterrupt:
            self.logger.info("🛑 程序中断")
        finally:
            # 清理持仓
            if self.positions:
                market_data = self.simulate_market_data()
                for symbol in list(self.positions.keys()):
                    self.close_position(self.positions[symbol], market_data, ["程序结束"])
            
            self.print_final_summary()
    
    def print_final_summary(self):
        """最终总结"""
        runtime = datetime.now() - self.start_time if self.start_time else timedelta(0)
        win_rate = (self.stats['winning_trades'] / max(self.stats['total_trades'], 1)) * 100
        roi = (self.capital - self.initial_capital) / self.initial_capital * 100
        
        summary = f"""
╔══════════════════════════════════════════════════════════════╗
║                    🏁 DipMaster测试完成                       ║
╠══════════════════════════════════════════════════════════════╣
║  ⏱️ 运行时间: {str(runtime).split('.')[0]}                     ║
║  💰 初始: ${self.initial_capital} → 最终: ${self.capital:.2f}   ║
║  📈 回报: {roi:+.2f}% | 盈亏: ${self.stats['total_pnl']:+.2f} ║
║  🎯 交易: {self.stats['total_trades']}笔 | 胜率: {win_rate:.1f}% ║
╚══════════════════════════════════════════════════════════════╝
        """
        print(summary)
        self.logger.info("🎉 交易结束")

def main():
    parser = argparse.ArgumentParser(description="DipMaster纸面交易")
    parser.add_argument('--config', '-c', default='config/paper_trading_config.json')
    parser.add_argument('--hours', '-t', type=int, default=168)
    parser.add_argument('--test', action='store_true', help='5分钟测试')
    
    args = parser.parse_args()
    
    if args.test:
        args.hours = 0.083
    
    try:
        with open(args.config, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        engine = DipMasterPaperEngine(config)
        asyncio.run(engine.run_trading_session(duration_hours=args.hours))
        
    except KeyboardInterrupt:
        print("\n🛑 程序中断")
    except Exception as e:
        print(f"❌ 错误: {e}")

if __name__ == "__main__":
    main()
EOF

# 第七步：创建启动脚本
cat > start_7day_test.sh << 'EOF'
#!/bin/bash
cd /opt/DipMaster-Trading-System

echo "🚀 启动DipMaster 7天纸面交易测试"
echo "时间: $(date)"

screen -dmS dipmaster-paper bash -c "
    cd /opt/DipMaster-Trading-System
    python3 run_paper_trading.py --hours 168 --config config/paper_trading_config.json
"

echo "✅ 测试已启动!"
echo "查看状态: screen -r dipmaster-paper"
echo "停止测试: screen -S dipmaster-paper -X quit"
screen -list
EOF

chmod +x start_7day_test.sh

# 第八步：创建监控脚本
cat > monitor.sh << 'EOF'
#!/bin/bash

echo "📊 DipMaster监控 - $(date)"
echo "========================="

if screen -list | grep -q dipmaster-paper; then
    echo "✅ 程序运行中"
else
    echo "❌ 程序未运行"
fi

echo ""
echo "系统状态:"
echo "内存: $(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2}')"
echo "磁盘: $(df -h . | awk 'NR==2{print $5}')"

echo ""
latest_log=$(ls -t logs/*.log 2>/dev/null | head -1)
if [ -n "$latest_log" ]; then
    echo "最新日志:"
    tail -10 "$latest_log"
fi

echo ""
echo "命令:"
echo "  进入会话: screen -r dipmaster-paper"
echo "  实时日志: tail -f logs/*.log"
echo "  停止测试: screen -S dipmaster-paper -X quit"
EOF

chmod +x monitor.sh

# 第九步：给脚本执行权限
chmod +x run_paper_trading.py

# 第十步：快速测试
echo "🧪 快速测试..."
python3 run_paper_trading.py --test

echo ""
echo "🎉 部署完成!"
echo "启动7天测试: ./start_7day_test.sh"
echo "监控状态: ./monitor.sh"