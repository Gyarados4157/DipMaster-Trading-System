# åœ¨é˜¿é‡Œäº‘VNCä¸­ç›´æ¥å¤åˆ¶ç²˜è´´æ‰§è¡Œä»¥ä¸‹å‘½ä»¤

# ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºé¡¹ç›®ç›®å½•
mkdir -p /opt/DipMaster-Trading-System
cd /opt/DipMaster-Trading-System

# ç¬¬äºŒæ­¥ï¼šå®‰è£…ä¾èµ–
yum update -y
yum install -y python3 python3-pip git screen htop

# ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºé…ç½®æ–‡ä»¶
mkdir -p config
cat > config/paper_trading_config.json << 'EOF'
{
  "strategy_name": "DipMaster_Linux_Paper_Trading",
  "version": "1.0.0",
  "trading": {
    "paper_trading": true,
    "initial_capital": 10000,
    "symbols": ["BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "BNBUSDT"],
    "max_concurrent_positions": 3,
    "position_size_usd": 800
  },
  "risk_management": {
    "global_settings": {
      "max_daily_loss_usd": 300,
      "max_drawdown_percent": 8.0
    }
  },
  "logging_and_monitoring": {
    "log_level": "INFO",
    "detailed_trade_logging": true,
    "save_results": true
  }
}
EOF

# ç¬¬å››æ­¥ï¼šåˆ›å»ºä¾èµ–æ–‡ä»¶
cat > requirements.txt << 'EOF'
numpy>=1.21.0
pandas>=1.3.0
asyncio
requests>=2.28.0
EOF

# ç¬¬äº”æ­¥ï¼šå®‰è£…PythonåŒ…
pip3 install -r requirements.txt

# ç¬¬å…­æ­¥ï¼šåˆ›å»ºäº¤æ˜“è„šæœ¬ (è¿™ä¸ªæ–‡ä»¶æ¯”è¾ƒå¤§ï¼Œåˆ†æ®µå¤åˆ¶)
# --- å…ˆåˆ›å»ºä¸»è„šæœ¬æ–‡ä»¶å¼€å¤´ ---
cat > run_paper_trading.py << 'EOF'
#!/usr/bin/env python3
"""DipMaster Linuxçº¸é¢äº¤æ˜“è„šæœ¬"""

import asyncio
import json
import logging
import signal
import sys
import time
import random
from datetime import datetime, timedelta
from pathlib import Path
import argparse

class DipMasterPaperEngine:
    def __init__(self, config):
        self.config = config
        self.running = False
        self.start_time = None
        self.capital = float(config['trading']['initial_capital'])
        self.initial_capital = self.capital
        self.positions = {}
        self.trade_history = []
        
        self.stats = {
            'total_signals': 0,
            'total_trades': 0,
            'winning_trades': 0,
            'total_pnl': 0.0,
            'max_drawdown': 0.0
        }
        
        self.setup_logging()
        self.logger = logging.getLogger(self.__class__.__name__)
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def setup_logging(self):
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_file = log_dir / f"dipmaster_paper_{timestamp}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s | %(levelname)s | %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
    
    def _signal_handler(self, signum, frame):
        self.logger.info(f"æ¥æ”¶åˆ°ä¿¡å· {signum}, åœæ­¢äº¤æ˜“...")
        self.running = False
    
    def simulate_market_data(self):
        """æ¨¡æ‹Ÿå¸‚åœºæ•°æ®"""
        base_prices = {
            'BTCUSDT': 43000, 'ETHUSDT': 2500, 'ADAUSDT': 0.45, 
            'SOLUSDT': 95, 'BNBUSDT': 310
        }
        
        market_data = {}
        for symbol in self.config['trading']['symbols']:
            base_price = base_prices.get(symbol, 100)
            price_change = random.uniform(-0.03, 0.03)
            current_price = base_price * (1 + price_change)
            
            market_data[symbol] = {
                'symbol': symbol,
                'price': round(current_price, 4),
                'price_change_pct': price_change * 100,
                'rsi_14': random.uniform(25, 75),
                'is_dip': price_change < -0.005,
                'volume_ratio': random.uniform(0.8, 2.5),
                'timestamp': datetime.now()
            }
        
        return market_data
    
    def detect_dipmaster_signal(self, symbol_data):
        """DipMasterä¿¡å·æ£€æµ‹"""
        symbol = symbol_data['symbol']
        
        conditions = {
            'rsi_condition': 30 <= symbol_data['rsi_14'] <= 50,
            'dip_condition': symbol_data['is_dip'],
            'volume_condition': symbol_data['volume_ratio'] > 1.3,
            'price_condition': symbol_data['price_change_pct'] < -0.2
        }
        
        score = sum(conditions.values())
        confidence = score / len(conditions)
        
        self.stats['total_signals'] += 1
        
        if confidence >= 0.75 and random.random() < 0.15:
            return {
                'symbol': symbol,
                'action': 'BUY',
                'price': symbol_data['price'],
                'confidence': confidence,
                'rsi': symbol_data['rsi_14'],
                'timestamp': datetime.now()
            }
        
        return None
    
    def execute_trade(self, signal):
        """æ‰§è¡Œäº¤æ˜“"""
        symbol = signal['symbol']
        
        if len(self.positions) >= self.config['trading']['max_concurrent_positions']:
            return False
        
        if symbol in self.positions:
            return False
        
        position_size = self.config['trading']['position_size_usd']
        
        trade = {
            'id': len(self.trade_history) + 1,
            'symbol': symbol,
            'entry_price': signal['price'],
            'position_size_usd': position_size,
            'entry_time': datetime.now(),
            'exit_price': None,
            'pnl': 0.0,
            'status': 'OPEN'
        }
        
        self.positions[symbol] = trade
        self.trade_history.append(trade)
        self.stats['total_trades'] += 1
        
        self.logger.info(f"ğŸ“ˆ å¼€ä»“: {symbol} @ ${signal['price']:.4f}, ${position_size}")
        return True
    
    def check_exit_conditions(self, position, market_data):
        """æ£€æŸ¥å‡ºåœºæ¡ä»¶"""
        symbol = position['symbol']
        current_price = market_data[symbol]['price']
        entry_price = position['entry_price']
        entry_time = position['entry_time']
        
        holding_time = datetime.now() - entry_time
        holding_minutes = holding_time.total_seconds() / 60
        pnl_pct = (current_price - entry_price) / entry_price
        
        exit_reasons = []
        
        # 15åˆ†é’Ÿè¾¹ç•Œ
        if holding_minutes >= 15:
            minute_in_hour = holding_minutes % 60
            if 14 <= minute_in_hour <= 16 or 29 <= minute_in_hour <= 31:
                exit_reasons.append("15åˆ†é’Ÿè¾¹ç•Œ")
        
        # ç›®æ ‡åˆ©æ¶¦
        if pnl_pct >= 0.008:
            exit_reasons.append("ç›®æ ‡åˆ©æ¶¦")
        
        # æ­¢æŸ
        if pnl_pct <= -0.012:
            exit_reasons.append("æ­¢æŸ")
        
        # æœ€å¤§æŒä»“æ—¶é—´
        if holding_minutes >= 180:
            exit_reasons.append("æœ€å¤§æŒä»“æ—¶é—´")
        
        return exit_reasons
    
    def close_position(self, position, market_data, exit_reasons):
        """å¹³ä»“"""
        symbol = position['symbol']
        current_price = market_data[symbol]['price']
        entry_price = position['entry_price']
        position_size = position['position_size_usd']
        
        pnl_pct = (current_price - entry_price) / entry_price
        pnl_usd = position_size * pnl_pct
        
        position['exit_price'] = current_price
        position['exit_time'] = datetime.now()
        position['pnl'] = pnl_usd
        position['status'] = 'CLOSED'
        
        self.capital += pnl_usd
        self.stats['total_pnl'] += pnl_usd
        
        if pnl_usd > 0:
            self.stats['winning_trades'] += 1
        
        holding_time = datetime.now() - position['entry_time']
        
        emoji = "ğŸ’°" if pnl_usd > 0 else "ğŸ“‰"
        self.logger.info(f"{emoji} å¹³ä»“: {symbol} @ ${current_price:.4f} | "
                        f"ç›ˆäº: ${pnl_usd:+.2f} ({pnl_pct*100:+.2f}%) | "
                        f"æ—¶é—´: {holding_time.total_seconds()/60:.1f}åˆ†é’Ÿ")
        
        del self.positions[symbol]
    
    def print_status(self):
        """æ‰“å°çŠ¶æ€"""
        if not self.start_time:
            return
        
        runtime = datetime.now() - self.start_time
        win_rate = (self.stats['winning_trades'] / max(self.stats['total_trades'], 1)) * 100
        roi = (self.capital - self.initial_capital) / self.initial_capital * 100
        
        status = f"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š DipMasterçŠ¶æ€ (è¿è¡Œ: {str(runtime).split('.')[0]})
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° èµ„é‡‘: ${self.capital:.2f} | ROI: {roi:+.2f}%
ğŸ“ˆ äº¤æ˜“: {self.stats['total_trades']} | èƒœç‡: {win_rate:.1f}%
ğŸ’¹ ç›ˆäº: ${self.stats['total_pnl']:+.2f} | æŒä»“: {len(self.positions)}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        """
        self.logger.info(status)
    
    async def run_trading_session(self, duration_hours=168):
        """è¿è¡Œäº¤æ˜“"""
        self.running = True
        self.start_time = datetime.now()
        
        self.logger.info(f"ğŸš€ DipMasterå¯åŠ¨! åˆå§‹èµ„é‡‘: ${self.capital}")
        self.logger.info(f"â±ï¸ è¿è¡Œæ—¶é•¿: {duration_hours}å°æ—¶")
        
        last_status_time = datetime.now()
        
        try:
            while self.running:
                if (datetime.now() - self.start_time).total_seconds() > duration_hours * 3600:
                    self.logger.info(f"â° è¾¾åˆ°è¿è¡Œæ—¶é—´ {duration_hours} å°æ—¶")
                    break
                
                market_data = self.simulate_market_data()
                
                # æ£€æŸ¥å‡ºåœº
                for symbol in list(self.positions.keys()):
                    position = self.positions[symbol]
                    exit_reasons = self.check_exit_conditions(position, market_data)
                    if exit_reasons:
                        self.close_position(position, market_data, exit_reasons)
                
                # æ£€æŸ¥å…¥åœº
                for symbol_data in market_data.values():
                    signal = self.detect_dipmaster_signal(symbol_data)
                    if signal:
                        self.execute_trade(signal)
                
                # 30åˆ†é’ŸçŠ¶æ€æŠ¥å‘Š
                if datetime.now() - last_status_time >= timedelta(minutes=30):
                    self.print_status()
                    last_status_time = datetime.now()
                
                await asyncio.sleep(60)  # 1åˆ†é’Ÿå‘¨æœŸ
                
        except KeyboardInterrupt:
            self.logger.info("ğŸ›‘ ç¨‹åºä¸­æ–­")
        finally:
            # æ¸…ç†æŒä»“
            if self.positions:
                market_data = self.simulate_market_data()
                for symbol in list(self.positions.keys()):
                    self.close_position(self.positions[symbol], market_data, ["ç¨‹åºç»“æŸ"])
            
            self.print_final_summary()
    
    def print_final_summary(self):
        """æœ€ç»ˆæ€»ç»“"""
        runtime = datetime.now() - self.start_time if self.start_time else timedelta(0)
        win_rate = (self.stats['winning_trades'] / max(self.stats['total_trades'], 1)) * 100
        roi = (self.capital - self.initial_capital) / self.initial_capital * 100
        
        summary = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ DipMasteræµ‹è¯•å®Œæˆ                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  â±ï¸ è¿è¡Œæ—¶é—´: {str(runtime).split('.')[0]}                     â•‘
â•‘  ğŸ’° åˆå§‹: ${self.initial_capital} â†’ æœ€ç»ˆ: ${self.capital:.2f}   â•‘
â•‘  ğŸ“ˆ å›æŠ¥: {roi:+.2f}% | ç›ˆäº: ${self.stats['total_pnl']:+.2f} â•‘
â•‘  ğŸ¯ äº¤æ˜“: {self.stats['total_trades']}ç¬” | èƒœç‡: {win_rate:.1f}% â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """
        print(summary)
        self.logger.info("ğŸ‰ äº¤æ˜“ç»“æŸ")

def main():
    parser = argparse.ArgumentParser(description="DipMasterçº¸é¢äº¤æ˜“")
    parser.add_argument('--config', '-c', default='config/paper_trading_config.json')
    parser.add_argument('--hours', '-t', type=int, default=168)
    parser.add_argument('--test', action='store_true', help='5åˆ†é’Ÿæµ‹è¯•')
    
    args = parser.parse_args()
    
    if args.test:
        args.hours = 0.083
    
    try:
        with open(args.config, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        engine = DipMasterPaperEngine(config)
        asyncio.run(engine.run_trading_session(duration_hours=args.hours))
        
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç¨‹åºä¸­æ–­")
    except Exception as e:
        print(f"âŒ é”™è¯¯: {e}")

if __name__ == "__main__":
    main()
EOF

# ç¬¬ä¸ƒæ­¥ï¼šåˆ›å»ºå¯åŠ¨è„šæœ¬
cat > start_7day_test.sh << 'EOF'
#!/bin/bash
cd /opt/DipMaster-Trading-System

echo "ğŸš€ å¯åŠ¨DipMaster 7å¤©çº¸é¢äº¤æ˜“æµ‹è¯•"
echo "æ—¶é—´: $(date)"

screen -dmS dipmaster-paper bash -c "
    cd /opt/DipMaster-Trading-System
    python3 run_paper_trading.py --hours 168 --config config/paper_trading_config.json
"

echo "âœ… æµ‹è¯•å·²å¯åŠ¨!"
echo "æŸ¥çœ‹çŠ¶æ€: screen -r dipmaster-paper"
echo "åœæ­¢æµ‹è¯•: screen -S dipmaster-paper -X quit"
screen -list
EOF

chmod +x start_7day_test.sh

# ç¬¬å…«æ­¥ï¼šåˆ›å»ºç›‘æ§è„šæœ¬
cat > monitor.sh << 'EOF'
#!/bin/bash

echo "ğŸ“Š DipMasterç›‘æ§ - $(date)"
echo "========================="

if screen -list | grep -q dipmaster-paper; then
    echo "âœ… ç¨‹åºè¿è¡Œä¸­"
else
    echo "âŒ ç¨‹åºæœªè¿è¡Œ"
fi

echo ""
echo "ç³»ç»ŸçŠ¶æ€:"
echo "å†…å­˜: $(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2}')"
echo "ç£ç›˜: $(df -h . | awk 'NR==2{print $5}')"

echo ""
latest_log=$(ls -t logs/*.log 2>/dev/null | head -1)
if [ -n "$latest_log" ]; then
    echo "æœ€æ–°æ—¥å¿—:"
    tail -10 "$latest_log"
fi

echo ""
echo "å‘½ä»¤:"
echo "  è¿›å…¥ä¼šè¯: screen -r dipmaster-paper"
echo "  å®æ—¶æ—¥å¿—: tail -f logs/*.log"
echo "  åœæ­¢æµ‹è¯•: screen -S dipmaster-paper -X quit"
EOF

chmod +x monitor.sh

# ç¬¬ä¹æ­¥ï¼šç»™è„šæœ¬æ‰§è¡Œæƒé™
chmod +x run_paper_trading.py

# ç¬¬åæ­¥ï¼šå¿«é€Ÿæµ‹è¯•
echo "ğŸ§ª å¿«é€Ÿæµ‹è¯•..."
python3 run_paper_trading.py --test

echo ""
echo "ğŸ‰ éƒ¨ç½²å®Œæˆ!"
echo "å¯åŠ¨7å¤©æµ‹è¯•: ./start_7day_test.sh"
echo "ç›‘æ§çŠ¶æ€: ./monitor.sh"